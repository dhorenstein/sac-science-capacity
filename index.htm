<!DOCTYPE html>
<html>
<head>
<title>SAC STEM Schedule Builder</title>
</head>
<body>

  <p><strong>Student profile:</strong>
  </p>

  <p>Major:
  <select id="selectmajor" onchange="updaterecommendations();">
  </select>
  </p>

  <p>Semester:
    <select id="selectsemester" onchange="updaterecommendations();">
    </select>
    <span id="labelsemester1">
    </span>
  </p>

  <div>
  <input type="radio" id="onsequenceradio" name="sequence" value="on" onchange="updaterecommendations();" checked>
  <label for="on">On-Sequence (semesters 1, 3, and&nbsp;5 in Fall or Intersession; semesters 2, 4, and&nbsp;6 in Spring or Summer)</label>
  </div>
  <div>
  <input type="radio" id="offsequenceradio" name="sequence" value="off" onchange="updaterecommendations();">
  <label for="on">Off-Sequence (semesters 1, 3, and&nbsp;5 in Spring or Summer; semesters 2, 4, and&nbsp;6 in Fall or Intersession)</label>
  </div>
  
  <p>&nbsp;
  </p>

  <p><strong>Summary:</strong>
  </p>
  <div id="summarydiv">
  </div>

  <p>&nbsp;
  </p>

  <p><strong>Recommended courses and available sections:</strong>
  </p>

  <div id="recommendationsdiv">
  </div>

  <p>&nbsp;
  </p>

  <p><strong>Weekly schedule from selected sections, with conflicts shown in <span style="color: red;">red</span></strong>:
  </p>

  <p>Monday:
  </p>
  <div id="schedule0div">
  </div>

  <p>Tuesday:
  </p>
  <div id="schedule1div">
  </div>

  <p>Wednesday:
  </p>
  <div id="schedule2div">
  </div>

  <p>Thursday:
  </p>
  <div id="schedule3div">
  </div>

  <p>Friday:
  </p>
  <div id="schedule4div">
  </div>

  <p>Saturday:
  </p>
  <div id="schedule5div">
  </div>

  <p>Sunday:
  </p>
  <div id="schedule6div">
  </div>

  <p><span id="labelsemester2">
  </span>:
  </p>
  <div id="schedule7div">
  </div>

  <p>&nbsp;
  </p>

  <p><strong>Section bottlenecks:</strong>
  </p>
  <div id="bottleneckdiv">
  </div>

  <p>&nbsp;
  </p>

  <p><strong>Course conflicts among all available sections, counting lecture and lab components separately:</strong>
  </p>
  <div id="conflictsdiv">
  </div>

  <p>&nbsp;
  </p>

  <p>Webpage updated 08&nbsp;September&nbsp;2021.
  </p>
  <p>Fall data from Fall&nbsp;2019.
  </p>
  <p>Intersession data from Intersession&nbsp;2019.
  </p>
  <p>Spring data from Spring&nbsp;2020.
  </p>
  <p>Summer data from Summer&nbsp;2019.
  </p>
  <p>Created by Daniel Horenstein, co-chair Physical Sciences, for Santa Ana College.
  </p>

</body>
<script>

  // list of majors
  let majors = [
  "Engineering",
  "Biology (UC)",
  "Biology (CSU)",
  "Biology (UC or CSU)", // csu biology major who decides after 2nd semester to meet uc recommendations
  "Chemistry",
  "Math",
  "Physics"
  ];

  // list of semesters
  let semesters = [
  "1",
  "2",
  "3",
  "4",
  "5",
  "6"
  ];

  // list of recommended courses for each major and semester
  // can include multiple options, ex. ["BIOL", 212, 214]
  // must be in same order as list of majors is in
  let recommendations = [
  [ // engineering
  [ // 1st semester
  ["MATH", 180],
  ["CHEM", 219]
  ], // end 1st semester engineering
  [ // 2nd semester
  ["MATH", 185],
  ["PHYS", 217],
  ["CHEM", 229]
  ], // end 2nd semester engineering
  [ // 3rd semester
  ["MATH", 280],
  ["PHYS", 227],
  ["ENGR", 235]
  ], // end 3rd semester engineering
  [ // 4th semester
  ["MATH", 287],
  ["PHYS", 237],
  ["ENGR", 240]
  ], // end 4th semester engineering
  [ // 5th semester
  ], // end 5th semester engineering
  [ // 6th semester
  ] // end 6th semester engineering
  ], // end engineering
  [ // biology (uc)
  [ // 1st semester
  ["CHEM", 219],
  ["MATH", 180]
  ], // end 1st semester biology (uc)
  [ // 2nd semester
  ["CHEM", 229],
  ["BIOL", 211],
  ["MATH", 185]
  ], // end 2nd semester biology (uc)
  [ // 3rd semester
  ["CHEM", 249],
  ["BIOL", 212, 214],
  ["PHYS", 210],
  ["MATH", 219]
  ], // end 3rd semester biology (uc)
  [ // 4th semester
  ["CHEM", 259],
  ["BIOL", 212, 214],
  ["PHYS", 211]
  ], // end 4th semester biology (uc)
  [ // 5th semester
  ], // end 5th semester biology (uc)
  [ // 6th semester
  ] // end 6th semester biology (uc)
  ], // end biology (uc)
  [ // biology (csu)
  [ // 1st semester
  ["CHEM", 219],
  ["MATH", 140]
  ], // end 1st semester biology (csu)
  [ // 2nd semester
  ["CHEM", 229],
  ["BIOL", 211],
  ["MATH", 162]
  ], // end 2nd semester biology (csu)
  [ // 3rd semester
  ["CHEM", 249],
  ["BIOL", 212, 214],
  ["PHYS", 279]
  ], // end 3rd semester biology (csu)
  [ // 4th semester
  ["CHEM", 259],
  ["PHYS", 289],
  ], // end 4th semester biology (csu)
  [ // 5th semester
  ], // end 5th semester biology (csu)
  [ // 6th semester
  ] // end 6th semester biology (csu)
  ], // end biology (csu)
  [ // biology (uc or csu)
  [ // 1st semester
  ["CHEM", 219],
  ["MATH", 140]
  ], // end 1st semester biology (uc or csu)
  [ // 2nd semester
  ["CHEM", 229],
  ["BIOL", 211],
  ["MATH", 162]
  ], // end 2nd semester biology (uc or csu)
  [ // 3rd semester
  ["CHEM", 249],
  ["BIOL", 212, 214],
  ["MATH", 180]
  ], // end 3rd semester biology (uc or csu)
  [ // 4th semester
  ["CHEM", 259],
  ["BIOL", 212, 214],
  ["MATH", 185, 219]
  ], // end 4th semester biology (uc or csu)
  [ // 5th semester
  ["PHYS", 210]
  ], // end 5th semester biology (uc orcsu)
  [ // 6th semester
  ["PHYS", 211]
  ] // end 6th semester biology (uc or csu)
  ], // end biology (csu)
  [ // chemistry
  [ // 1st semester
  ["CHEM", 219],
  ["MATH", 180]
  ], // end 1st semester chemistry
  [ // 2nd semester
  ["CHEM", 229],
  ["MATH", 185]
  ], // end 2nd semester chemistry
  [ // 3rd semester
  ["CHEM", 249],
  ["MATH", 180],
  ["PHYS", 217]
  ], // end 3rd semester chemistry
  [ // 4th semester
  ["CHEM", 259],
  ["PHYS", 227]
  ], // end 4th semester chemistry
  [ // 5th semester
  ], // end 5th semester chemistry
  [ // 6th semester
  ] // end 6th semester chemistry
  ], // end chemistry
  [ // math
  [ // 1st semester
  ["MATH", 162]
  ], // end 1st semester math
  [ // 2nd semester
  ["MATH", 180]
  ], // end 2nd semester math
  [ // 3rd semester
  ["MATH", 185],
  ], // end 3rd semester math
  [ // 4th semester
  ["MATH", 280]
  ], // end 4th semester math
  [ // 5th semester
  ], // end 5th semester math
  [ // 6th semester
  ] // end 6th semester math
  ], // end math
  [ // physics
  [ // 1st semester
  ["MATH", 180],
  ["CMPR", 120]
  ], // end 1st semester physics
  [ // 2nd semester
  ["MATH", 185],
  ["PHYS", 217],
  ["CMPR", 121]
  ], // end 2nd semester physics
  [ // 3rd semester
  ["MATH", 280],
  ["PHYS", 227]
  ], // end 3rd semester physics
  [ // 4th semester
  ["MATH", 287],
  ["PHYS", 237]
  ], // end 4th semester physics
  [ // 5th semester
  ], // end 5th semester physics
  [ // 6th semester
  ] // end 6th semester physics
  ] // end physics
  ];

  // assign first free index to modified classes
  function nextindex() {
    var freeindex = 1;
    while ((fallclasses.has(freeindex)) ||
           (springclasses.has(freeindex))) {
      freeindex++;
    }
    return freeindex;
  }

  // list of all relevant classes
  // maps from section number to course info
  // course info: dept, course, day, start, end, day, start, end, etc.
  // retrieved asynchronously near end of document when page loads
  // uses fall 2019 and spring 2020 data
  let fallclasses = new Map();
  let springclasses = new Map();

  // maps day of week from number (0-6) to letter
  let dayofweek = new Map();
  dayofweek.set(0, "M")
  dayofweek.set(1, "T")
  dayofweek.set(2, "W")
  dayofweek.set(3, "R")
  dayofweek.set(4, "F")
  dayofweek.set(5, "S")
  dayofweek.set(6, "U")
  dayofweek.set(7, "X") // can be intersession or summer
  // online not needed since time of day irrelevant

  // maps majors (in order of majors array) from name to number, indexed at 0
  let majorcolumns = new Map();
  for (let i = 0; i < majors.length; i++) {
    majorcolumns.set(majors[i], i);
  }

  // maps semesters (in order of semesters array) from name to number, indexed at 0
  let semesterrows = new Map();
  for (let i = 0; i < semesters.length; i++) {
    semesterrows.set(semesters[i], i);
  }

  // generates set of semester numbers and separates into spring or fall
  // defines function that can be called when sequence (on-sequence or off-sequence) changes
  // call function when page loads
  let fallsemesters = new Set();
  let springsemesters = new Set();
  function updatesequence() {
    fallsemesters.clear();
    springsemesters.clear();
    for (let semesternumber of semesters) {
      
      if (((semesternumber % 2 == 1) && (document.getElementById("onsequenceradio").checked)) ||
          ((semesternumber % 2 == 0) && (document.getElementById("offsequenceradio").checked))) {

        fallsemesters.add(semesternumber);
      
      } else {
        
        springsemesters.add(semesternumber);
      
      } // if statement
    
    } // for loop (all semester numbers)
    
    // update semester label as Fall or Spring depending on selected sequence
    var selectedsemester = document.getElementById("selectsemester").value;
    if (((selectedsemester % 2 == 1) && (document.getElementById("onsequenceradio").checked)) ||
        ((selectedsemester % 2 == 0) && (document.getElementById("offsequenceradio").checked))) {
      
      document.getElementById("labelsemester1").innerHTML = "Fall or Intersession";
      document.getElementById("labelsemester2").innerHTML = "Intersession"; // nonstandard "day" name
      
    } else {
      
      document.getElementById("labelsemester1").innerHTML = "Spring or Summer";
      document.getElementById("labelsemester2").innerHTML = "Summer"; // nonstandard "day" name
            
    }
    
  } // function updatesequence()
  updatesequence();

  // generate a map from semester+dept+course to (unpopulated) set of available sections
  // set of semester+dept_course keys needs to be maintained separately
  // [later, after retrieving list of sections, populate map from semester+dept+course with set of available sections]
  let coursesections = new Map();
  var recommendedcoursekeys = new Set();
  for (let i = 0; i < recommendations.length; i++) {
    // step through all majors

    for (let j = 0; j < recommendations[i].length; j++) {
      // for each major (index i), step through all semesters

      for (let k = 0; k < recommendations[i][j].length; k++) {
        // for major (index i) and semester (index j), step through all courses

        for (let l = 1; l < recommendations[i][j][k].length; l++) {
          // for course in question (index k), step through all options

          let dept = recommendations[i][j][k][0];
          let course = recommendations[i][j][k][l];
          if ((j == 0) || (j == 2)) {

            key = "Fall " + dept + " " + course;

          } else {

            key = "Spring " + dept + " " + course;

          } // if statement
          coursesections.set(key, new Set());
          recommendedcoursekeys.add(key);

        } // index l (option)

      } // index k (course)

    } // index j (semester)

  } // index i (major)

  // populates drop-down list of majors
  for (let i = 0; i < majors.length; i++) {

    document.getElementById("selectmajor").innerHTML = document.getElementById("selectmajor").innerHTML + "<option value=\"" + majors[i] + "\">" + majors[i] + "</option>"

  } // index i (major)

  // populates drop-down list of semesters
  for (let i = 0; i < semesters.length; i++) {

    document.getElementById("selectsemester").innerHTML = document.getElementById("selectsemester").innerHTML + "<option value=\"" + semesters[i] + "\">" + semesters[i] + "</option>"

  } // index i (semester)

  // converts 24hr time to 12hr time, ex. "1340" to "1:40 PM"
  function formattime(time24hr) {
    var time12hr = 0;
    if (time24hr < 1300) {
      time12hr = time24hr;
    } else {
      time12hr = time24hr - 1200;
    }
    if (time24hr < 1200) {
      time12hr = time12hr + " AM";
    } else {
      time12hr = time12hr + " PM";
    }
    if (time24hr = 0) {
      time12hr = "1200 AM";
    }
    time12hr = time12hr.slice(0, time12hr.length - 5) + ":" + time12hr.slice(-5);
    return time12hr;
  }

  // names course, ex. "PHYS 217 MW 11:55 AM - 1:20 PM and M 8:35 AM - 11:45 AM"
  function prettyname(courseinfo) {
    // dept, course, day, start, end, day, start, end

    var displayname = courseinfo[0] + " " + courseinfo[1] + " ";
    for (let i = 0; i < (courseinfo.length - 2) / 3; i++) {
      // steps through every course component (every set of day, start, end)

      displayname = displayname + courseinfo[i * 3 + 2] + " " + formattime(courseinfo[i * 3 + 3]) + " - " + formattime(courseinfo[i * 3 + 4]);
      if (i + 1 < (courseinfo.length - 2) / 3) {

        displayname = displayname + " and ";

      } // if statement

    } // index i (course component)
    return displayname;

  } // function prettyname()

  // returns singular case of a word
  // case-sensitive
  function singularcase(number, word) {
    var returnstr;
    if (number != 1) {
      returnstr = word; // return original word if plural
    } else {
      switch(word) {
        case "are":
          returnstr = "is";
          break;
        case "combinations":
          returnstr = "combination";
          break;
        case "these":
          returnstr = "this";
          break;
        case "These":
          returnstr = "This";
          break;
        case "conflicts":
          returnstr = "conflict";
          break;
        case "do":
          returnstr = "does";
          break;
        case "schedules":
          returnstr = "schedule";
          break;
        case "sections":
          returnstr = "section";
          break;
        case "components":
          returnstr = "component";
          break;
        default:
          returnstr = word; // return original word if no singular case found
          console.log("Singular case not found for: " + word);
      } // switch case
    } // if statement
    return returnstr;
  } // function singularcase()

  // updates on-screen schedule
  function updateschedule() {

    // declare variables
    var selectedsemester = document.getElementById("selectsemester").value;
    var selectedclasses = document.getElementsByTagName("select");
    var schedulearray = [[], [], [], [], [], [], [], []]; // include index 7 for intersession/summer

    // chooses which map of courses (fall or spring) to use
    var coursesmap = fallclasses;
    if (springsemesters.has(selectedsemester)) {

      coursesmap = springclasses;

    } // if statement

    for (let i = 2; i < selectedclasses.length; i++) {
      // steps through user's selection for each recommended class
      // skip first 2 select tags (on- and off-sequence are radio tags, not select)

      // get the section number and convert it from a string to a number
      var selectedsection = parseInt(selectedclasses[i].value, 10); // to base10 integer
      
      // if no section is offered, there won't be any data with which to update the daily schedule
      if (coursesmap.has(selectedsection)) {
      
        var courseinfo = coursesmap.get(selectedsection);
        // dept, course, day, start, end, day, start, end, etc.
        for (let j = 0; j < (courseinfo.length - 2) / 3; j++) {
          // steps through every course component (every set of day, start, end)

          for (let k = 0; k < 8; k++) {
            // steps through days of week, including intersession/summer

            if (courseinfo[j * 3 + 2].indexOf(dayofweek.get(k)) >= 0) {
              // executes if the day letter is in the course component day, ex. "M" in "MW"

              // names the course component, ex. "PHYS 217 M 8:35 AM - 11:45 AM"
              // lecture and lab named separately due to index j loop
              // adds course component name to that day's schedule (from index k)
              schedulearray[k].push([courseinfo[j * 3 + 3], courseinfo[j * 3 + 4], courseinfo[0] + " " + courseinfo[1] + " " + courseinfo[j * 3 + 2] + " " + formattime(courseinfo[j * 3 + 3]) + " - " + formattime(courseinfo[j * 3 + 4])]); // start, end, name

            } // if statement

          } // index k (day of week)

        } // index j (course component)
      
      } // if statement (is 1+ section offered?)

    } // index i (user-selected section)

    for (let i = 0; i < 8; i++) {
      // steps through days of week, including intersession/summer

      // clear that day's on-screen schedule
      document.getElementById("schedule" + i + "div").innerHTML = "<p>";

      // sort that day's schedule by start time
      // (later - const) will be larger than (earlier - const) is
      schedulearray[i].sort((class1, class2) => class1[0] - class2[0]);
      for (let j = 0; j < schedulearray[i].length; j++) {
        // steps through every course scheduled for that day

        var colorstr = "black";
        var starttime = schedulearray[i][j][0];
        for (let k = 0; k < j; k++) {
          // steps through all courses that begin earlier than the current course does

          previousendtime = schedulearray[i][k][1];
          if (starttime < previousendtime) {
            // if the current start time is before any previous course's end time

            colorstr = "red";

          } // if statement

        } // index k (all courses that began earlier in day)

        // show course name in that day's on-screen schedule
        // use red text if current course conflicts with any earlier course
        document.getElementById("schedule" + i + "div").innerHTML = document.getElementById("schedule" + i + "div").innerHTML + "<span style=\"color: " + colorstr + ";\">" + schedulearray[i][j][2] + "</span><br>";

      } // index j (all courses scheduled for that day)

      document.getElementById("schedule" + i + "div").innerHTML = document.getElementById("schedule" + i + "div").innerHTML + "</p>";

    } // index i (days of the week)

  } // function updateschedule()

  // updates on-screen list of recommended courses, with associated drop-down menus
  function updaterecommendations() {

    // update status message in case of long calculation time
    document.getElementById("summarydiv").innerHTML = "Recalculating &hellip;";

    // declare variables
    var selectedmajor = document.getElementById("selectmajor").value;
    var selectedsemester = document.getElementById("selectsemester").value;
    var selectedrecommendations = recommendations[majorcolumns.get(selectedmajor)][semesterrows.get(selectedsemester)];

    // sort recommended courses alphabetically: biology, chemistry, etc.
    selectedrecommendations.sort();

    // clear the on-screen list of recommended courses
    document.getElementById("recommendationsdiv").innerHTML = "";

    // chooses which map of courses (fall or spring) to use
    // first, check whether on- or off-sequence
    updatesequence();
    var coursesmap = fallclasses;
    var semester = "Fall";
    if (springsemesters.has(selectedsemester)) {

      coursesmap = springclasses;
      semester = "Spring";

    } // if statement

    for (let i = 0; i < selectedrecommendations.length; i++) {
      // steps through all recommended courses for selected major and semester

      // name the recommended course, ex. "BIOL 212 or 214"
      var dept = selectedrecommendations[i][0];
      var course = "";
      for (let j = 1; j < selectedrecommendations[i].length; j++) {
        // steps through any options, ex. 212 or 214

        if (course != "") {
          // prepends "or" if not the first course to be listed

          course = course + " or ";

        } // if statement
        course = course + selectedrecommendations[i][j];

      } // index j (options for recommendation)

      // create a drop-down menu (not yet populated) for the recommended course
      document.getElementById("recommendationsdiv").innerHTML = document.getElementById("recommendationsdiv").innerHTML + "<p>" + dept + " " + course + ": <select id=\"selectrecommendation" + i + "\" onchange=\"updateschedule()\"></select></p>";

    } // index i (list of recommended courses for given major and semester)

    for (let i = 0; i < selectedrecommendations.length; i++) {
      // steps through all recommended courses for selected major and semester

      // declare variables
      var dept = selectedrecommendations[i][0];
      //var coursecombinations = 0;

      for (let j = 1; j < selectedrecommendations[i].length; j++) {
        // for the recommendation in question (index i), steps through any options
        // ex. BIOL (j=0) 212 (j=1) or 214 (j=2)

        var course = selectedrecommendations[i][j]; // course number

        if (coursesections.has(semester + " " + dept + " " + course)) {
          // only executes if at least 1 section of course is offered in given semester
        
          for (let section of Array.from(coursesections.get(semester + " " + dept + " " + course)).sort()) {
            // for the course in question (index j), steps through all sections

            // populate the course's drop-down list with names
            // names are generated from section numbers with prettyname(sectionnumber)
            document.getElementById("selectrecommendation" + i).innerHTML = document.getElementById("selectrecommendation" + i).innerHTML + "<option value=" + section + ">" + prettyname(coursesmap.get(section)) + "</option>";
          
          } // for loop (list of all available sections for given course)
          
        } // if statement (1+ sections of course offered in given semester)

      } // index j (options for recommended course)
      
      // if no sections of given course are offered in given semester, disable drop-down menu
      // otherwise, ensure drop-down menu is enabled
      if (document.getElementById("selectrecommendation" + i).length == 0) {
        
        document.getElementById("selectrecommendation" + i).disabled = true;
        document.getElementById("selectrecommendation" + i).innerHTML = "<option value=\"\">[No sections offered in selected semester]</option>";
        
      } else {
        
        document.getElementById("selectrecommendation" + i).disabled = false;
        
      } // if statement (1+ sections offered in given semester)

    } // index i (list of recommended courses for given major and semester)

    // to count combinations with scheduling conflicts, create combinations first
    var sectioncombinations = [];
    for (let i = 0; i < selectedrecommendations.length; i++) {
      // steps through all recommended courses for selected major and semester

      // declare variables
      var dept = selectedrecommendations[i][0];
      var nmodified = 0; // used as counter below
      // before modifying combinations list, count, existing combinations
      var ncombinations = sectioncombinations.length;

      for (let j = 1; j < selectedrecommendations[i].length; j++) {
        // for the recommendation in question (index i), steps through any options
        // ex. BIOL (j=0) 212 (j=1) or 214 (j=2)

        // declare variables
        var course = selectedrecommendations[i][j];
        //var nmodified = 0; // used as counter below

        if (coursesections.has(semester + " " + dept + " " + course)) {
          // only executes if at least 1 section of course is offered in given semester

          for (let k = Math.max(0, 2 - j); k < coursesections.get(semester + " " + dept + " " + course).size; k++) {
            // for the course in question (index j), k counts the sections offered
            // for each new section offered, repeat the list of existing sections
            // no repetition is needed for first section, eg. skip k=0
            //   but only when j=1! otherwise, appending to sections that meet current recommendation (remember j=0 is skipped to find dept name)

            for (let l = 0; l < ncombinations; l++) {

              // to create a deep copy, unpack the elements of each array into a new array
              //   ... is called "spread" notation
              sectioncombinations.push([...sectioncombinations[l]]);

            } // index l (number of existing combinations)

          } // index k (number of sections offered for new course)
          
        } // if statement (1+ sections of given course offered in given semester

      } // index j (options for recommended courses)

      for (let j = 1; j < selectedrecommendations[i].length; j++) {
        // for the recommendation in question (index i), steps through any options
        // ex. BIOL (j=0) 212 (j=1) or 214 (j=2)

        // declare variables
        var course = selectedrecommendations[i][j];
        
        if (coursesections.has(semester + " " + dept + " " + course)) {
          // only executes if at least 1 section of course is offered in given semester

          for (let section of Array.from(coursesections.get(semester + " " + dept + " " + course)).sort()) {
            // for the course in question (index j), steps through all sections

            if (i == 0) {
              // for first recommended course, append one-element arrays of sections

              sectioncombinations.push([section]);

            } else {

              for (let k = 0; k < ncombinations; k++) {
                // pairs every existing combination with the new section

                sectioncombinations[nmodified + k].push(section);

              } // index k (number of existing combinations)

              // update number of combinations modified *after* modification finished
              // otherwise, double-counted with nmodified + k
              nmodified = nmodified + ncombinations;

            } // if statement

          } // for loop (list of all sections offered for course in question)
          
        } // if statement (1+ sections of given course offered in given semester)

      } // index j (options for recommended course)

    } // index i (recommended courses for given major and semester)

    // count number of combinations
    var ncombinations = sectioncombinations.length;

    // count combinations with scheduling conflicts or 10+ hour days
    var conflictingcourses = new Map(); // don't need to keep track of keys if strings
    var nconflictedschedules = 0;
    var nlongdays = 0;
    var reasonablesections = [];
    for (let i = 0; i < selectedrecommendations.length; i++) {
      reasonablesections.push(new Set());
    }
    for (let combination of sectioncombinations) {

      var schedulearray = [[], [], [], [], [], [], [], []]; // include index 7 for intersession/summer
      // note that this schedulearray in updaterecommendations() is distinct from the one in updateschedule()

      for (let section of combination) {

        var courseinfo = coursesmap.get(section);
        // dept, course, day, start, end, day, start, end, etc.
        for (let i = 0; i < (courseinfo.length - 2) / 3; i++) {
          // steps through every course component (every set of day, start, end)

          for (let j = 0; j < 8; j++) {
            // steps through days of week, including intersession/summer

            if (courseinfo[i * 3 + 2].indexOf(dayofweek.get(j)) >= 0) {
              // executes if day letter is in course component day, ex. "M" in "MW"

              // names the course component, ex. "PHYS 217 M 8:35 AM - 11:45 AM"
              // lecture and lab named separately due to index j loop
              // adds course component name to that day's schedule (from index j)
              schedulearray[j].push([courseinfo[i * 3 + 3], courseinfo[i * 3 + 4], courseinfo[0] + " " + courseinfo[1] + " " + courseinfo[i * 3 + 2] + " " + formattime(courseinfo[i * 3 + 3]) + " - " + formattime(courseinfo[i * 3 + 4])]); // start, end, name

            } // if statement

          } // index j (day of week)

        } // index i (course component)

      } // for loop (each section of combination)

      var conflictfound = false;
      var longdayfound = false;
      var previousdayend = 1; // initial value 12:01 AM on Sunday before week starts
      for (let i = 0; i < 8; i++) {
        // steps through days of week, including intersession/summer

        // sort that day's schedule by start time
        // (later - const) will be larger than (earlier - const) is
        schedulearray[i].sort((class1, class2) => class1[0] - class2[0]);

      } // index i (day of week)

      // update previousdayend if any course is scheduled on sunday
      // will be updated each day after checking for long schedule, around line 929
      if (schedulearray[6].length > 0) {
        // do NOT update index to 7 to include intersession/summer courses, which will meet in the subsequent semester

        for (let i = 0; i < schedulearray[6].length; i++) {
          // steps through every course scheduled for that day

          if (schedulearray[6][i][1] > previousdayend) {

            previousdayend = schedulearray[6][i][1];

          } // if statement

        } // index i (each course scheduled on sunday)
        
      } // if statement

      for (let i = 0; i < 8; i++) {
        // steps through days of week, including intersession/summer

        for (let j = 0; j < schedulearray[i].length; j++) {
          // steps through every course scheduled for that day

          var starttime = schedulearray[i][j][0];
          for (let k = 0; k < j; k++) {
            // steps through all courses that begin earlier than the current course does

            previousendtime = schedulearray[i][k][1];
            if (starttime < previousendtime) {
              // if the current start time is before any previous course's end time

              conflictfound = true;
              var conflictingname1 = schedulearray[i][j][2];
              var conflictingname2 = schedulearray[i][k][2];

              for (let conflictingname of [conflictingname1, conflictingname2]) {

                if (!conflictingcourses.has(conflictingname)) {
                  // add key if this is first conflict identified

                  conflictingcourses.set(conflictingname, new Set());

                } // if statement

              } // for loop

              conflictingcourses.get(conflictingname1).add(conflictingname2);
              conflictingcourses.get(conflictingname2).add(conflictingname1);

            } // if statement

          } // index k (all courses that began earlier in day)

        } // index j (all courses scheduled for that day)

        if ((!conflictfound) && (schedulearray[i].length > 0)) {
          // only check for long day if at least one class and no schedule conflicts

          var firststart = schedulearray[i][0][0]; // first start time on that day
          var lastend = schedulearray[i][schedulearray[i].length - 1][1]; // last end time on that day

          if ((lastend - firststart > 1000) || // day lasts more than 10 hours
              (firststart < previousdayend + 1200 - 2400)) { // must return fewer than 12 hours after previous day ended

            longdayfound = true;

          } // if statement

        } // if statement

        // update ending time to make sure return next day is at least 12 hours later
        if (schedulearray[i].length > 0) {

          previousdayend = schedulearray[i][schedulearray[i].length - 1][1];

        } else {

          previousdayend = 1; // last class "ends" at 12:01 AM if no classes that day

        } // if statement

      } // index i (day of week)

      if (conflictfound) {

        nconflictedschedules++;

      } else if (longdayfound) {

        nlongdays++;

      } else {

        for (let i = 0; i < combination.length; i++) {

          // courses listed in order as seen on screen, ex. biol, chem, engr, etc.
          reasonablesections[i].add(combination[i]);

        } // index i (section in combination)

      } // if statement

    } // for loop (each schedule combination)

    // count how many other courses each course conflicts with
    var conflictingresults = [];
    for (let [coursename, conflictingset] of conflictingcourses) {
      conflictingresults.push([coursename, conflictingset.size]);
    }
    // sort by number of courses each course conflicts with *in descending order*
    conflictingresults.sort((course1, course2) => course2[1] - course1[1]);
    // update on-screen list of conflicting classes
    document.getElementById("conflictsdiv").innerHTML = "";
    if (conflictingresults.length > 0) {
      for (let [coursename, nconflictedsections] of conflictingresults) {

        document.getElementById("conflictsdiv").innerHTML =
          document.getElementById("conflictsdiv").innerHTML + "<p>" + coursename +
          " conflicts with " + nconflictedsections + "&nbsp;section " +
          singularcase(nconflictedsections, "components") + ".</p>";

        var specificconflictingcourses = Array.from(conflictingcourses.get(coursename))
        var conflictinglistelementsstr = "";

        for (i = 0; i < specificconflictingcourses.length; i++) {

          conflictinglistelementsstr = conflictinglistelementsstr + "<li><p>" + specificconflictingcourses[i] + "</p></li>";

        } // index i (names of sections conflicted with)

        document.getElementById("conflictsdiv").innerHTML =
          document.getElementById("conflictsdiv").innerHTML + "<ul>" +
          conflictinglistelementsstr + "</ul>";

      } // for loop (array counting sections conflicted with)

    } else {

      document.getElementById("conflictsdiv").innerHTML = "There are no course conflicts.";

    } // if statement

    // calculate statistics about conflicting courses
    var fractionconflicted;
    if (ncombinations != 0) {
      fractionconflicted = Math.round(nconflictedschedules / ncombinations * 100);
    } else {
      fractionconflicted = 0;
    } // if statement
    var npossible = ncombinations - nconflictedschedules;
    var fractionlong;
    if (npossible != 0) {
      fractionlong = Math.round(nlongdays / npossible * 100);
    } else {
      fractionlong = 0;
    } // if statement
    var nsectionsbottleneck = 10000; // will never have 10000 sections to choose from
    for (let recommendedset of reasonablesections) {
      if (recommendedset.size < nsectionsbottleneck) {
        nsectionsbottleneck = recommendedset.size;
      } // if statement
    } // for loop (set of reasonable sections that meet each recommendation)

    // display bottlenecks where number of sections limits number of students served
    document.getElementById("bottleneckdiv").innerHTML = "";
    if (nsectionsbottleneck > 0) {
      for (let i = 0; i < selectedrecommendations.length; i++) {
        var nreasonablesections = reasonablesections[i].size;
        if (nreasonablesections == nsectionsbottleneck) {
          // name the recommended course, ex. "BIOL 212 or 214"
          var dept = selectedrecommendations[i][0];
          var course = "";
          for (let j = 1; j < selectedrecommendations[i].length; j++) {
            // steps through any options, ex. 212 or 214

            if (course != "") {
              // prepends "or" if not the first course to be listed

              course = course + " or ";

            } // if statement
            course = course + selectedrecommendations[i][j];

          } // index j (names the course)

          document.getElementById("bottleneckdiv").innerHTML = document.getElementById("bottleneckdiv").innerHTML + "<p>For " + dept + " " + course + " in a reasonable schedule as defined above, students must choose among the following sections.</p>";

          // list the section names from reasonable combinations through the bottleneck
          var listelementsstr = "";
          for (let section of Array.from(reasonablesections[i]).sort()) {

            listelementsstr = listelementsstr + "<li>" + prettyname(coursesmap.get(section)) + "</li>";

          } // for loop (section numbers for each recommendation in reasonable schedules)

          document.getElementById("bottleneckdiv").innerHTML =
            document.getElementById("bottleneckdiv").innerHTML +
            "<ol>" + listelementsstr + "</ol><p>" +
            singularcase(nsectionsbottleneck, "These") + " " + nsectionsbottleneck + " " +
            singularcase(nsectionsbottleneck, "sections") +
            "&nbsp;&middot;&nbsp;30&nbsp;students per section = " +
            (nsectionsbottleneck * 30) + "&nbsp;students served.</p>";

        } // if statement

      } // index i (set of reasonable sections that meet each recommendation)

    } else {

      document.getElementById("bottleneckdiv").innerHTML = "There are no reasonable schedule combinations as defined above.";

    } // if statement

    // display summary of conflicting schedules
    if (selectedrecommendations.length > 0) {

      document.getElementById("summarydiv").innerHTML =
        "<p>There " +
        singularcase(ncombinations, "are") + " " +
        ncombinations + "&nbsp;schedule " +
        singularcase(ncombinations, "combinations") + " with the recommended courses listed below.</p>" +
        "<p>Of " +
        singularcase(ncombinations, "these") + " " +
        singularcase(ncombinations, "combinations") + ", " +
        nconflictedschedules + "&nbsp;(" + fractionconflicted + "%) " +
        singularcase(ncombinations, "are") + " not possible due to scheduling conflicts. These conflicts are listed at the bottom of this page.</p>" +
        "<p>The following criteria are used to assess whether any given combination is reasonable.</p><ul>" +
        "<li><p>A student should not have to be on campus for more than 10&nbsp;hours a day on any day of the week.</p></li>" +
        "<li><p>A student should not have to return to campus fewer than 12&nbsp;hours after his or her last class from the previous day.</p></li>" +
        "</ul><p>Of the " + npossible + "&nbsp;" +
        singularcase(npossible, "combinations") + " that " +
        singularcase(npossible, "are") + " possible, " +
        nlongdays + "&nbsp;(" + fractionlong + "%) " +
        singularcase(nlongdays, "do") + " not meet the above criteria for a reasonable schedule.</p>" +
        "<p>Accounting for overlapping combinations and assuming a typical class size of 30&nbsp;students, the remaining " +
        (npossible - nlongdays) + "&nbsp;reasonable " +
        singularcase((npossible - nlongdays), "schedules") +
        " can accommodate approximately " + (nsectionsbottleneck * 30) +
        "&nbsp;students total per semester.</p>";

    } else {

      document.getElementById("summarydiv").innerHTML = "There are no recommended courses for this major in this semester.";

    }

    // also need to update the on-screen weekly schedule
    updateschedule();

  } // function updaterecommendations()
  
  // just before page loads, retrieve list of courses
  let requestURL = "https://dhorenstein.github.io/sac-science-capacity/courses.json";
  let xmlhttp = new XMLHttpRequest();
  xmlhttp.open("GET", requestURL);
  xmlhttp.send();
  xmlhttp.onload = function() {
    const allcourses = JSON.parse(xmlhttp.responseText);
    for (let course of allcourses) {
      // course structure: [semester, section number, [course info]]
      // replace section number of -1 with nextindex()
      if (course[1] == -1) {
        
        course[1] = nextindex();
        
      } // if statement (replace modified course indexes)
      if ((course[0] == "Fall") || (course[0] == "Intersession")) {
        
        fallclasses.set(course[1], course[2]); // key: section number; value: course info
        
      } else {
        
        springclasses.set(course[1], course[2]); // key: section number; value: course info
        
      } // if statement (add each course to list of either fall or spring classes)
      
    } // for loop (process each course received asynchronously)
    
    // populate map from semester+dept+course with set of available sections
    for (let [semestertype, coursesmap] of [["Fall", fallclasses],
                                            ["Spring", springclasses]]) {
      for (let [sectionnumber, courseinfo] of coursesmap.entries()) {
        // steps through all classes offered in the given semester

        var dept = courseinfo[0];
        var course = courseinfo[1];
        var key = semestertype + " " + dept + " " + course;
        if (recommendedcoursekeys.has(key)) {
          // only executes if course is recommended for at least one major

          coursesections.get(key).add(sectionnumber); // covers fall and spring semesters

        } // if statement

      } // for loop of all fall OR spring classes

    } // for loop (to cover fall AND spring semesters)
    
    // when page loads and courses have been retrieved, show recommended courses for initial major and semester
    updaterecommendations();
    
  } // return function from asynchronous json request

</script>

</html>
